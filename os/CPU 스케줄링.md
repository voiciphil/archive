# CPU 스케줄링

## CPU 스케줄링
#### 멀티 프로그래밍 시스템의 목적
멀티 프로그래밍 시스템의 목적은 CPU의 이용률을 최대로 하기 위해 항상 어떤 프로세스를 실행하는 데 있다. 예를 들어, 프로세스가 실행되다 입출력 요청을 했을 때 프로세스는 입출력이 완료될 때까지 기다려야 한다.  멀티 프로그래밍 시스템에서는 이때 다른 프로세스를 실행시켜 CPU가 쉬지 않도록 한다.

#### CPU 스케줄링
CPU 스케줄링이란 준비(ready) 상태의 프로세스 중 다음으로 CPU를 사용할 프로세스를 결정하는 작업이다.

#### 선점형 스케줄링과 비선점형 스케줄링
* **선점형(preemptive) 스케줄링**: CPU를 점유하고 있는 프로세스를 강제로 내리고 다른 프로세스가 CPU를 사용하도록 함
* **비선점형(nonpreemptive) 스케줄링**: CPU를 점유하고 있는 프로세스는 강제로 CPU를 빼앗기지 않고 종료되거나 대기(waiting) 상태로 들어갈 때 다른 프로세스가 CPU를 사용할 수 있음

## 스케줄링 알고리즘
### 선입 선처리 알고리즘(First-Come First-Served Scheduling, FCFS)

#### 특징
* 먼저 준비 큐에 도착한 프로세스를 가장 우선으로 스케줄링한다.
* 비선점형 스케줄링이다.

#### 단점
* 호위 효과(convoy effect): 수행 시간이 긴 하나의 프로세스가 CPU를 내려 놓을 때까지 다른 프로세스들은 실행되지 못한다.

### 최단 작업 우선 스케줄링(Shortest-Job-First Scheduling, SJF)

#### 특징
* 다음에 가장 짧게 CPU를 사용할 프로세스를 먼저 스케줄링한다.
* 현실적으로 프로세스의 다음 CPU 사용 시간을 알 수 없으므로 이전의 사용 시간을 이용해 다음 사용 시간을 예측한다.

#### 선점형 SJF vs 비선점형 SJF
* **선점형 SJF**: 현재 CPU를 사용하는 프로세스보다 더 짧은 프로세스가 준비 큐에 들어오면 CPU를 빼앗는다. 최소 잔여 시간 우선 스케줄링(Shortest Remaining Time First, SRTF)이라고도 불린다.
* **비선점형 SJF**: 더 짧은 프로세스가 준비 큐에 들어와도 CPU를 빼앗지 않는다.

#### 장점
* 최소의 평균 대기 시간을 보장한다.

#### 단점
* 기아 상태(starvation): 사용 시간이 긴 프로세스는 거의 스케줄링되지 않는다.

### 라운드 로빈 스케줄링(Round-Robin Scheduling, RR)

#### 특징
* 시간 할당량(time quantum), 또는 타임 슬라이스(time slice)라고 하는 작은 단위의 시간을 정의한다. 프로세스가 CPU를 점유하고 그 시간이 지나면 CPU를 빼앗고 다른 프로세스를 실행시킨다. 프로세스가 정해진 시간보다 짧은 시간동안 CPU를 사용하고 내려놓는다면 바로 다음 프로세스가 스케줄링된다.
* 다음으로 실행시킬 프로세스를 고르는 방법은 FCFS와 동일하다. CPU를 빼앗긴 프로세스는 준비 큐의 가장 뒤로 들어가며, 따라서 가장 나중에 실행되게 된다.
* 시간 할당량을 너무 작게 설정해서도 안 되고 너무 크게 설정해서도 안 된다. 시간 할당량이 너무 작으면 문맥 교환의 오버헤드가 커지고, 너무 크면 FCFS와 같아진다.
* 현대적인 CPU 스케줄링 방법이다.
* 선점형 스케줄링이다.

#### 장점
* 준비 큐에 n개의 프로세스가 있고 시간 할당량이 q라면, 어떤 프로세스도 (n - 1) * q 초과의 시간을 기다리지 않는다.
* 프로세스가 기다리는 시간이 CPU를 사용할 시간만큼 증가하여 공정한 스케줄링이라고 할 수 있다.

#### 단점
* 일반적으로 평균 대기 시간이 길다.

### 우선순위 스케줄링(Priority Scheduling)

#### 톡징
* 준비 큐에서 가장 우선순위가 높은 프로세스를 선택하여 스케줄링한다.
* SJF는 우선순위 스케줄링의 특수한 케이스이다.
* SJF와 마찬가지로 선점형과 비선점형이 존재한다.

#### 단점
* **무한 봉쇄(indefinite bloking)** 또는 **기아 상태(starvation)**: 우선순위가 낮은 프로세스는 거의 스케줄링되지 않는다. 오랫동안 대기하는 프로세스들의 우선순위를 점차적으로 높이는 방식(aging)으로 해결할 수 있다.
