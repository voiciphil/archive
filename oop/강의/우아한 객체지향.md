# 우아한 객체지향

**의존성을 이용해 설계를 진화시키기**

### 의존성

* 설계: 코드를 어떻게 배치할 것인가에 대한 의사결정

* 어떻게 설계할 것인가? **변경에 초점**을 맞춰라. 같이 변경되는 것을 같이 놔라.

* 의존성: B가 A에 의존할 때 A가 변경될 때 B도 영향을 받을 **가능성이 있다**.

### 클래스 의존성

- 연관 관계: A 클래스의 필드에 B 클래스의 객체 참조가 있을 때
- 의존 관계: A 클래스의 메서드에 매개변수, 반환형, 지역변수로 B 클래스의 객체가 있을 때
- 상속 관계: A가 B를 상속
- 실체화 관계: A가 B를 구현

### 패키지 의존성

* 다른 패키지에 존재하는 클래스 간에 의존성이 있으면 두 패키지 간에 의존성이 있다.

### 의존성 규칙

- 양방향 의존 관계를 피해라.
- 다중성이 적은 방향을 선택하라.
- 의존성이 필요없다면 제거하라.
- 패키지 사이의 의존성 사이클이 생기면 안 된다.

### 설계를 진화시키기 위한 출발점

- 의존성 관점에서 설계를 검토하라.

### 두 가지 문제

- 객체 참조로 인해 결합도가 상승한다.
- 패키지 의존성 사이클이 생긴다.

### 중간 객체를 이용한 의존성 사이클 끊기

- DIP: 구체적인 클래스에 의존하지 말고, **추상적인 클래스에 의존**해라. (추상적인 클래스가 꼭 인터페이스나 추상 클래스일 필요가 없다.)

### 객체 참조의 문제점

- 모든 객체가 연결되어 있기 때문에, 모든 객체에 접근 가능하고, 수정 가능하다.

### 어떤 객체들을 묶고 어떤 객체들을 분리할 것인가?

- 함께 생성되고 함께 삭제되는 객체들을 함께 묶어라.
- 도메인 제약사항을 공유하는 (같이 변경되는) 객체들을 함께 묶어라.
- 가능하면 분리하라.

### 객체 참조 끊기

- 참조를 끊고 Id와 Repository를 통해 탐색하라.

### 객체 참조를 Id로 변경하면 컴파일 에러가 발생한다!

- 일단 컴파일 에러가 발생하는 부분을 다른 객체로 옮긴다.
- 절차지향적인 로직으로 해결한다.
- 도메인 이벤트를 발행하여 해결한다.

### 참조를 끊었는데 패키지 의존성 사이클이 생긴다면?

- DIP: **인터페이스를 이용해 의존성을 역전**시킨다.
- **패키지를 분리**한다.

### 의존성을 정리하면서 얻을 수 있는 효과

* 패키지를 분리하고 나면 도메인 개념이 명확해진다.
* 도메인 단위로 모듈화할 수 있다. (도메인 이벤트를 통해 도메인 간 소통)
* 모듈화된 도메인을 토대로 시스템을 분리할 수 있다. (시스템 이벤트를 통해 시스템 간 소통)

### 강의 자료

* [강의](https://youtu.be/dJ5C4qRqAgA)
* [첫 번째 예제 코드](https://github.com/eternity-oop/Woowahan-OO-01-object-reference)
* [두 번째 예제 코드](https://github.com/eternity-oop/Woowahan-OO-02-domain-service)
* [세 번째 예제 코드](https://github.com/eternity-oop/Woowahan-OO-03-domain-event)

